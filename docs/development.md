# Заметки о разработке
Содержание:
* [2026-01-08. О библиотеке eventsourcing](#2026-01-08-%D0%BE-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B5-eventsourcing)
## 2026-01-08. О библиотеке `eventsourcing`
В рамках сомообразования планировал разобраться с библиотекой [eventsourcing](https://eventsourcing.readthedocs.io).
Сам Event Sourcing меня не интересовал, но меня интересовали `Aggregate`, `Application`, и простой `Event`, который позволяет обмениваться сообщениями внутри приложения. Но, неожидано оказалось, что `eventsourcing` идеально закрывает одну из проблем текущего проекта.

Текущий проект развивается, как frontend-first. Структура данных формируется из текущих потребностей, а не продумывается заранее. Как следствие, нельзя заранее расписать всё в виде django-моделей. А значит развитие кода привело бы появлению сотен миграций. Поэтому, сеанс игры - это json, который хранится в соответсвующем поле модели. При запуске игры этот json транслируется в pydantic-модель. Никаких миграций не появляется, но при каждом изменении структуры данных, сохранённые данные становятся не валидными. Поэтому приходится уничтожать БД, после каждого изменения кода.

В последнее время, данные стабилизировались и можно было бы переписать структуру в виде djnago-моделей. Но меня беспокоит, что загрузка состояния игры - это развесистый SQL с очень большим числом JOIN. Это может сделать и код и тесты значительно медленее.

При использовании `eventsourcing` запрос получается намного проще, а состояние игры не берётся готовое, а формируется на основе событий игры.
При этом, изменения структуры данных не будут ломать сохранёные игры.
Если при классическом подходе торомизить будут все операции, то при использовании `eventsourcing` тормозить будет только начальная загрузка и только для игр с большим числом событий, зато остальное будет значительно быстрее.
А главное, тесты могут работать без БД, что значительно ускоряет обратную связь.
