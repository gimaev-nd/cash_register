# Заметки о разработке
Содержание:

* [2026-01-08. О библиотеке eventsourcing](#2026-01-08-о-библиотеке-eventsourcing)
* [2026-01-12. Рассуждения о BDD](#2026-01-12-рассуждения-о-bdd)

## 2026-01-08. О библиотеке `eventsourcing`
В рамках сомообразования планировал разобраться с библиотекой [eventsourcing](https://eventsourcing.readthedocs.io).
Сам Event Sourcing меня не интересовал, но меня интересовали `Aggregate`, `Application`, и простой `Event`, который позволяет обмениваться сообщениями внутри приложения. Но, неожидано оказалось, что `eventsourcing` идеально закрывает одну из проблем текущего проекта.

Текущий проект развивается, как frontend-first. Структура данных формируется из текущих потребностей, а не продумывается заранее. Как следствие, нельзя заранее расписать всё в виде django-моделей. А значит развитие кода привело бы появлению сотен миграций. Поэтому, сеанс игры - это json, который хранится в соответсвующем поле модели. При запуске игры этот json транслируется в pydantic-модель. Никаких миграций не появляется, но при каждом изменении структуры данных, сохранённые данные становятся не валидными. Поэтому приходится уничтожать БД, после каждого изменения кода.

В последнее время, данные стабилизировались и можно было бы переписать структуру в виде djnago-моделей. Но меня беспокоит, что загрузка состояния игры - это развесистый SQL с очень большим числом JOIN. Это может сделать и код и тесты значительно медленее.

При использовании `eventsourcing` запрос получается намного проще, а состояние игры не берётся готовое, а формируется на основе событий игры.
При этом, изменения структуры данных не будут ломать сохранёные игры.
Если при классическом подходе торомизить будут все операции, то при использовании `eventsourcing` тормозить будет только начальная загрузка и только для игр с большим числом событий, зато остальное будет значительно быстрее.
А главное, тесты могут работать без БД, что значительно ускоряет обратную связь.

## 2026-01-12. Рассуждения о BDD
Я не планировал применять на этом проекте DDD, но, так уж получилось, что на этом проекте DDD внедряется быстрее, чем там, где это планировалось. Я пришёл к DDD страным путём, через тесты. Когда проект основан на Django Rest Framework, то практически все тесты - это e2e тесты. А они медленые, а значит их не может быть много. В DDD API и ORM - это лишь транспорт, который доставляет данные к бизнес-логике. А тесты бизнес-логики простые и лёгкие. Таким образом можно писать очень много тестов и не страдать от потери произвоительности. Вторым важным моментом я вляется то, что тесты максимально близки бизнесу и их можно показывать аналитику.

При чём тут BDD? При том, что при тестировании только доменного слоя, теряются e2e-тесты. А без них нельзя, часто бывает, что отдельные части работают, а вместе не работают. Типичный e2e содержит инструкции вида "сходить по такому-то url и проверить, что пришло в json" или "найти кнопку с такой-то надписью, и кликнуть на неё". Это не бизнес описание. Вот тут-то и появляется BDD. В моей картине мира, любая задача должна быть рассказана аналитиком в виде Gherkin-описания (язык для BDD-тестов) до её решения. Один BDD-тест может быть имплементирован несколько раз: фронтендер может "кликнуть кнопку", а бекендер "сходить по url своего приложения". Если собрать все BDD-тесты, то можно получить очень точное представление о том, как работает приложение.

На моём последнем месте работы, документацией были задачи, которые ставились программистам. Сначала шла эпик-задача, в которой подробно описывалась фича: бизнес-история, ожидаемая структура БД, ожидаемое api. Со временем, появлялись новые задачи, которые превносили изменения в функционал. Программисты добавляли ссылки на задачи в каждом коммите. Поэтому, даже годы спустя, была возможность понять благодаря какой задаче появилась та или иная логика в коде. Но полную картину прихоилось собирать из множества задач. У аналитика такого инструмента не было, поэтому было квестом узнать где описано, какое-то поведение системы. В итоге я пришёл к выводу, что поведение системы должно описываться языке бизнеса, но так, чтобы это становилось тестами. Тогда это не удалось сделать, т.к. pytest-bdd не поддерживал русский язык.

Для нормального внедрения BDD должны быть решены несколько задач:

- Единое хранилище тестов показывающее состояние выполнения тестов.
- Редактор тестов
- Должна быть возможность видеть только те тесты, которые реализованы в последнем релизе
- Должна быть возможность видеть тесты, которые были изменены или отключены в последнем релизе
- Должна быть возможность видеть предыдущую версию теста

Без этого BDD не несёт пользы, а готовых решений я не нашёл.

Я пока написал один тест и уже вижу сложности. Имплементация BDD-тестов имеет большую вариативность, т.е. требует большого числа `if`. В частности, вариативность вознивает из-за склонений русского языка.
